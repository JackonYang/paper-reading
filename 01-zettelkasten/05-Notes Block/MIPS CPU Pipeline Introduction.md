# MIPS CPU 流水线基础与中级概念

Created: 2022-05-05 01:41

前置介绍 [Y86 seq impl notes](Y86%20seq%20impl%20notes.md)

## RISC 指令级

RISC 处理器，经典的  5 级流水线。

1. IF(Fetch): 含 PC update(+4)
2. ID(Decode): 读寄存器堆的东西
3. EX(Execute): 算数运算，也可能是计算有效地址（存储器引用指令）
4. MEM(Memory): 读/写存储器
5. WB(Write Back): 结果写回寄存器堆

![](https://tva1.sinaimg.cn/large/e6c9d24egy1h1xcuti6zkj20lj087mxs.jpg)

## 流水线化

只要每个时钟周期都发射一条新的指令，就是流水化。
引入流水线寄存器（pipeline register）在 step 之间传递中间结果。

实现上，没有这么简单，复杂度来自：Hazard(流水线冒险)

性能上：

1. 时钟周期卡在最慢的 step 上。ALU 和存储器一般没法拆。
2. 单条指令的 latency 提升。新增了流水线开销，主要是
	1. 流水线寄存器延迟
	2. 时钟偏差。
3. 过深的流水线，收益反而下降。提升的倍数，是 1 / 流水线深度，不是线性的提升。

## 流水线冒险 Hazard

ISA 提供了程序执行的顺序说明。
hazard 不是来自乱序执行。而是，为了消除 hazard 的影响，引入了乱序执行。

冒险，使流水线停顿 1 个时钟周期（或多个）。通常叫流水线气泡，或气泡。汇编的 nop 指令，穿过各时钟周期，什么样也不做。

3 类冒险：

1. 结构冒险。一般是 ISA 或电路设计的问题，有时也是成本考虑的妥协。一般不用关心。
2. 数据冒险。前面写的寄存器，后面立即读。间隔的时钟周期数不够。流水线改变了读写访问顺序。
3. 分支冒险。也叫控制冒险。

### 数据冒险

消除方法：

1. forwarding(bypass) 转发。
	- 加硬件，把输出直接写入流水线寄存器，传到下去。
	- 涉及 Mem 操作的指令(load/use)，没法用旁路解决。
2. 流水线互锁。
	- 解决 load/use hazard。
	- 锁的时候，就要加 nop 停顿。降低流水线效率。
	- 这种指令一般不多，总体效率影响不大。

### 分支冒险

这里讨论的主要是条件跳转。在 [Y86 Pipelining](Y86%20Pipelining.md) 里讨论了其他分支冒险。

编译时，4 种机制（静态）：

1. 冻结或冲刷流水线。保留或删除分支后的所有指令。
2. 所有分支看作未选中。
3. 所有分支看作选中。
4. 延迟分支。等分支结果的间隙里，先执行后续指令。能选的指令有限，而且，编译期的预测能力有限。

### 分支预测

静态分支预测，编译时，利用之前运行过程收集的一览数据。

动态分支预测。分支预测缓冲区，又叫分支历史表。2 位预测机制，预测错 2 次，反转 cache。4k 的缓冲区，SPEC89 的最终错误率 1-18%

整数程序的分支率，一般更高。预测精度低于科学运算。错误率 11% : 4%

## 流水线的实现

笔记跳过

## 妨碍流水线实现的难题

1. 异常。比如 IO 类，断点（debug），整数算数溢出。等
2. 指令集的复杂性

## 跳过更多高级问题

## References

1.
